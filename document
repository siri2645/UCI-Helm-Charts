Ingress inginx:

We started by deploying an EKS cluster. Next, we deployed the ingress-nginx Helm chart. The process involved:

1.	Creating a namespace specifically for the ingress controller, named ingress-controller.
2.	Deploying the ingress Helm chart within this namespace.

Each Helm chart comes with a default values.yaml file, which can be modified to customize the deployment according to our needs.

default values file:

Internal Loadbalancer line no 537: we can enable the internal load balancer and add the necessary annotations to configure it properly.

Tls Cerfificate: we can also include a certificate annotation in the annotations section.

servicetype-line no 552: Here, we can change the service type from ClusterIP to LoadBalancer so that the service can be accessed from outside the cluster.

Servicetype line no 466: Here, we can switch the external service type from LoadBalancer to ClusterIP because we're using an internal load balancer.

Admissionwebhook line no 728: Disable the webhook here why because, when webhook is enabled, it automatically generate dynamic admission control on api request. It will not allow to delete or update anything related to external secrets. Webhook will locks the current configuration.


Jenkins:

we deployed the Jenkins Helm chart in the EKS Cluster
       1.    Creating a namespace specifically for the jenkins, named ingress-controller.
       2.	Deploying the Jenkins Helm chart within this namespace.

Default values file
 
Path based routing line no 173: For Jenkins path based routing we can add “/jenkins”
Disable the ingress line no 654: disable the default ingress and deploy the ingress yaml file because of pathbased routing.


SonarQube: 

we deployed the SonarQube Helm chart in the EKS Cluster
       1.    Creating a namespace specifically for the SonarQube, named ingress-controller.
2.	Deploying the SonarQube Helm chart within this namespace.

Default Values file:

Path based routing: For sonarqube path based routing Update these values at the end of the file.
                                                    extraEnv:
                                                             sonar.web.context: /SonarQube
                            line no-179: readinessProbe: sonarWebContext: /sonarqube/
                            line no-190: livenessProbe: sonarWebContext: /sonarqube/
                            line no-201: startupProbe: sonarWebContext: /sonarqube/
Disable the ingress line no 102: Disable the default ingress and deploy the ingress yaml file because of path based routing.

Database line no 438: Here we configure the SonarQube with AWS RDS 
Postgresql line no 454: here we disable the default database 



JFrog: 

we deployed the Jfrog Helm chart in the EKS Cluster
       1.    Creating a namespace specifically for the Jfrog, named ingress-controller.
       2.	Deploying the Jfrog Helm chart within this namespace.

Default values file:

Add keys line no 17,18: For security reasons, we can generate the master and join keys and specify these keys in the values file.
Enable the ingress line no 112: Activate path-based ingress for JFrog
ingress-nginx,enabled false line no: 1276 : 
Service,type line no 1555 : 
Database line no 1727: Configure the jfrog with AWS RDS.
Postgresql line no 1684: Disable the Default Database  


External secrets:

To retrieve AWS RDS credentials from AWS Secrets Manager and make them available in the EKS cluster, we deploy the External Secrets Helm chart along with the External Secrets YAML file and SecretStore YAML file.
We use an automation script that includes role-policy.sh, secret-manager.sh, external-secrets.yaml, and secret-store.yaml to accomplish this. 
This script handles the deployment and configuration needed to fetch the credentials from AWS Secrets Manager to EKS cluster.

We have default values file for external secrets helm chart

Changes:

Disable webhook line no 235: Disabled the webhook because it generates dynamic admission control on API requests, preventing deletion or updates related to external secrets. The webhook locks the current configuration.

Disable certController line no 398: false

Role-policy.sh line no (4-13): we need to update the required details.
External-secrets.yaml line no (16 and 20): here we change the aws rds key value(remoteRef key).
                                    Line no 4: if you want to change the external secrets file name also 
                                    Line no 5: here we can mention the namespace name
                                    Line no 9: if you want to change the secretstore file name like secretstore to sonar-secretstore
                                    Line no 12: here we can mention the target file name. the rds credentials are stored in this file. 
Secretstore.yaml line no 4: here which name we are mentioned in external secrets (line no 9) that name and this name should be same. 
                            Line no 5: here we need to mention the namespace name.
                            Line no 10: here we can mention the region name.
                            Line no 14: here we can mention the service account name
Jfrog-secrets-update.sh line no (4 to 9): here we can mention the required details. (this file we configured for jfrog only).





